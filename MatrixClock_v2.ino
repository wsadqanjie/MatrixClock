// MatrixClock V2
#include <SPI.h>
#include <Ticker.h>
#include <NTPClient.h>
#include <ESP8266WiFi.h>
#include <WiFiClient.h>
#include <WiFiUdp.h>
#include <Wire.h>
#include <time.h>



#define SDA      5      // Pin sda (I2C)
#define SCL     4      // Pin scl (I2C)
#define CS      15     // Pin cs  (SPI)
#define anzMAX  6      // LED模块数量

char* WIFI_SSID = "MyIOT";    // 请更改成你自己的wifi名称
char* WIFI_PWD = "12345678";  // 请更改成你自己的wifi 密码

byte reconnections = 0;     //连接次数

unsigned short maxPosX = anzMAX * 8 - 1;     //计算X最大值
unsigned short LEDarr[anzMAX][8];           //要显示的字符矩阵 (40*8)
unsigned short helpArrMAX[anzMAX * 8];      //helperarray for chardecoding
unsigned short helpArrPos[anzMAX * 8];      //helperarray pos of chardecoding
unsigned int z_PosX = 0;                    //时间显示中的X位置
unsigned int d_PosX = 0;                   //数据显示在显示器中的X轴位置
bool f_tckr1s = false;
bool f_tckr50ms = false;
bool f_tckr24h = false;


//DS3231数据
const unsigned char DS3231_ADDRESS = 0x68;
const unsigned char secondREG = 0x00;
const unsigned char minuteREG = 0x01;
const unsigned char hourREG = 0x02;
const unsigned char WKREG = 0x03;
const unsigned char dateREG = 0x04;
const unsigned char monthREG = 0x05;
const unsigned char yearREG = 0x06;
const unsigned char controlREG = 0x0E;
const unsigned char tempMSBREG = 0x11;
const unsigned char tempLSBREG = 0x12;

struct DateTime {
  unsigned short sec1, sec2, sec12, min1, min2, min12, hour1, hour2, hour12;
  unsigned short day1, day2, day12, mon1, mon2, mon12, year1, year2, year12, WK;
} TM;


Ticker tckr;

WiFiUDP udp;
NTPClient timeClient(udp, "ntp1.aliyun.com",8*60*60, 30*60*1000);

//月份
char M_arr[12][5] = { { '.', 'J', 'a', 'n', '.' }, { '.', 'F', 'e', 'b', '.' },
    { '.', 'M', 'a', 'r', '.' }, { '.', 'A', 'p', 'r', '.' }, { '.', 'M', 'a',
        'y', ' ' }, { '.', 'J', 'u', 'n', 'e' }, { '.', 'J', 'u', 'l', 'y' }, {
        '.', 'A', 'u', 'g', '.' }, { '.', 'S', 'e', 'p', 't' }, { '.', 'O', 'c',
        't', '.' }, { '.', 'N', 'o', 'v', '.' }, { '.', 'D', 'e', 'c', '.' } };
//星期
char WK_arr[7][4] = { { 'S', 'u', 'n', ',' }, { 'M', 'o', 'n', ',' }, { 'T', 'u', 'e', ',' }, {
    'W', 'e', 'd', ',' }, { 'T', 'h', 'u', ',' }, { 'F', 'r', 'i', ',' }, { 'S', 'a', 't', ',' } };

// 字体5x8在8x8矩阵中，0,0在右上角
unsigned short const font1[96][9] = { { 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00 },   // 0x20, Space
    { 0x07, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00, 0x04, 0x00 },   // 0x21, !
    { 0x07, 0x09, 0x09, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00 },   // 0x22, "
    { 0x07, 0x0a, 0x0a, 0x1f, 0x0a, 0x1f, 0x0a, 0x0a, 0x00 },   // 0x23, #
    { 0x07, 0x04, 0x0f, 0x14, 0x0e, 0x05, 0x1e, 0x04, 0x00 },   // 0x24, $
    { 0x07, 0x19, 0x19, 0x02, 0x04, 0x08, 0x13, 0x13, 0x00 },   // 0x25, %
    { 0x07, 0x04, 0x0a, 0x0a, 0x0a, 0x15, 0x12, 0x0d, 0x00 },   // 0x26, &
    { 0x07, 0x04, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 },   // 0x27, '
    { 0x07, 0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02, 0x00 },   // 0x28, (
    { 0x07, 0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08, 0x00 },   // 0x29, )
    { 0x07, 0x04, 0x15, 0x0e, 0x1f, 0x0e, 0x15, 0x04, 0x00 },   // 0x2a, *
    { 0x07, 0x00, 0x04, 0x04, 0x1f, 0x04, 0x04, 0x00, 0x00 },   // 0x2b, +
    { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02 },   // 0x2c, ,
    { 0x07, 0x00, 0x00, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x00 },   // 0x2d, -
    { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00 },   // 0x2e, .
    { 0x07, 0x01, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, 0x00 },   // 0x2f, /
    { 0x07, 0x0e, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0e, 0x00 },   // 0x30, 0
    { 0x07, 0x04, 0x0c, 0x04, 0x04, 0x04, 0x04, 0x0e, 0x00 },   // 0x31, 1
    { 0x07, 0x0e, 0x11, 0x01, 0x02, 0x04, 0x08, 0x1f, 0x00 },   // 0x32, 2
    { 0x07, 0x0e, 0x11, 0x01, 0x06, 0x01, 0x11, 0x0e, 0x00 },   // 0x33, 3
    { 0x07, 0x02, 0x06, 0x0a, 0x12, 0x1f, 0x02, 0x02, 0x00 },   // 0x34, 4
    { 0x07, 0x1f, 0x10, 0x1e, 0x01, 0x01, 0x11, 0x0e, 0x00 },   // 0x35, 5
    { 0x07, 0x06, 0x08, 0x10, 0x1e, 0x11, 0x11, 0x0e, 0x00 },   // 0x36, 6
    { 0x07, 0x1f, 0x01, 0x02, 0x04, 0x08, 0x08, 0x08, 0x00 },   // 0x37, 7
    { 0x07, 0x0e, 0x11, 0x11, 0x0e, 0x11, 0x11, 0x0e, 0x00 },   // 0x38, 8
    { 0x07, 0x0e, 0x11, 0x11, 0x0f, 0x01, 0x02, 0x0c, 0x00 },   // 0x39, 9
    { 0x04, 0x00, 0x03, 0x03, 0x00, 0x03, 0x03, 0x00, 0x00 },   // 0x3a, :
    { 0x07, 0x00, 0x0c, 0x0c, 0x00, 0x0c, 0x04, 0x08, 0x00 },   // 0x3b, ;
    { 0x07, 0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02, 0x00 },   // 0x3c, <
    { 0x07, 0x00, 0x00, 0x1f, 0x00, 0x1f, 0x00, 0x00, 0x00 },   // 0x3d, =
    { 0x07, 0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, 0x00 },   // 0x3e, >
    { 0x07, 0x0e, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04, 0x00 },   // 0x3f, ?
    { 0x07, 0x0e, 0x11, 0x17, 0x15, 0x17, 0x10, 0x0f, 0x00 },   // 0x40, @
    { 0x07, 0x04, 0x0a, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x00 },   // 0x41, A
    { 0x07, 0x1e, 0x11, 0x11, 0x1e, 0x11, 0x11, 0x1e, 0x00 },   // 0x42, B
    { 0x07, 0x0e, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0e, 0x00 },   // 0x43, C
    { 0x07, 0x1e, 0x09, 0x09, 0x09, 0x09, 0x09, 0x1e, 0x00 },   // 0x44, D
    { 0x07, 0x1f, 0x10, 0x10, 0x1c, 0x10, 0x10, 0x1f, 0x00 },   // 0x45, E
    { 0x07, 0x1f, 0x10, 0x10, 0x1f, 0x10, 0x10, 0x10, 0x00 },   // 0x46, F
    { 0x07, 0x0e, 0x11, 0x10, 0x10, 0x13, 0x11, 0x0f, 0x00 },   // 0x37, G
    { 0x07, 0x11, 0x11, 0x11, 0x1f, 0x11, 0x11, 0x11, 0x00 },   // 0x48, H
    { 0x07, 0x0e, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0e, 0x00 },   // 0x49, I
    { 0x07, 0x1f, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0c, 0x00 },   // 0x4a, J
    { 0x07, 0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11, 0x00 },   // 0x4b, K
    { 0x07, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1f, 0x00 },   // 0x4c, L
    { 0x07, 0x11, 0x1b, 0x15, 0x11, 0x11, 0x11, 0x11, 0x00 },   // 0x4d, M
    { 0x07, 0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11, 0x00 },   // 0x4e, N
    { 0x07, 0x0e, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00 },   // 0x4f, O
    { 0x07, 0x1e, 0x11, 0x11, 0x1e, 0x10, 0x10, 0x10, 0x00 },   // 0x50, P
    { 0x07, 0x0e, 0x11, 0x11, 0x11, 0x15, 0x12, 0x0d, 0x00 },   // 0x51, Q
    { 0x07, 0x1e, 0x11, 0x11, 0x1e, 0x14, 0x12, 0x11, 0x00 },   // 0x52, R
    { 0x07, 0x0e, 0x11, 0x10, 0x0e, 0x01, 0x11, 0x0e, 0x00 },   // 0x53, S
    { 0x07, 0x1f, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x00 },   // 0x54, T
    { 0x07, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0e, 0x00 },   // 0x55, U
    { 0x07, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0a, 0x04, 0x00 },   // 0x56, V
    { 0x07, 0x11, 0x11, 0x11, 0x15, 0x15, 0x1b, 0x11, 0x00 },   // 0x57, W
    { 0x07, 0x11, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x11, 0x00 },   // 0x58, X
    { 0x07, 0x11, 0x11, 0x0a, 0x04, 0x04, 0x04, 0x04, 0x00 },   // 0x59, Y
    { 0x07, 0x1f, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1f, 0x00 },   // 0x5a, Z
    { 0x07, 0x0e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0e, 0x00 },   // 0x5b, [
    { 0x07, 0x10, 0x10, 0x08, 0x04, 0x02, 0x01, 0x01, 0x00 },   // 0x5c, '\'
    { 0x07, 0x0e, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0e, 0x00 },   // 0x5d, ]
    { 0x07, 0x04, 0x0a, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00 },   // 0x5e, ^
    { 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x00 },   // 0x5f, _
    { 0x07, 0x04, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 },   // 0x60, `
    { 0x07, 0x00, 0x0e, 0x01, 0x0d, 0x13, 0x13, 0x0d, 0x00 },   // 0x61, a
    { 0x07, 0x10, 0x10, 0x10, 0x1c, 0x12, 0x12, 0x1c, 0x00 },   // 0x62, b
    { 0x07, 0x00, 0x00, 0x00, 0x0e, 0x10, 0x10, 0x0e, 0x00 },   // 0x63, c
    { 0x07, 0x01, 0x01, 0x01, 0x07, 0x09, 0x09, 0x07, 0x00 },   // 0x64, d
    { 0x07, 0x00, 0x00, 0x0e, 0x11, 0x1f, 0x10, 0x0f, 0x00 },   // 0x65, e
    { 0x07, 0x06, 0x09, 0x08, 0x1c, 0x08, 0x08, 0x08, 0x00 },   // 0x66, f
    { 0x07, 0x00, 0x0e, 0x11, 0x13, 0x0d, 0x01, 0x01, 0x0e },   // 0x67, g
    { 0x07, 0x10, 0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x00 },   // 0x68, h
    { 0x05, 0x00, 0x02, 0x00, 0x06, 0x02, 0x02, 0x07, 0x00 },   // 0x69, i
    { 0x07, 0x00, 0x02, 0x00, 0x06, 0x02, 0x02, 0x12, 0x0c },   // 0x6a, j
    { 0x07, 0x10, 0x10, 0x12, 0x14, 0x18, 0x14, 0x12, 0x00 },   // 0x6b, k
    { 0x05, 0x06, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x00 },   // 0x6c, l
    { 0x07, 0x00, 0x00, 0x0a, 0x15, 0x15, 0x11, 0x11, 0x00 },   // 0x6d, m
    { 0x07, 0x00, 0x00, 0x16, 0x19, 0x11, 0x11, 0x11, 0x00 },   // 0x6e, n
    { 0x07, 0x00, 0x00, 0x0e, 0x11, 0x11, 0x11, 0x0e, 0x00 },   // 0x6f, o
    { 0x07, 0x00, 0x00, 0x1c, 0x12, 0x12, 0x1c, 0x10, 0x10 },   // 0x70, p
    { 0x07, 0x00, 0x00, 0x07, 0x09, 0x09, 0x07, 0x01, 0x01 },   // 0x71, q
    { 0x07, 0x00, 0x00, 0x16, 0x19, 0x10, 0x10, 0x10, 0x00 },   // 0x72, r
    { 0x07, 0x00, 0x00, 0x0f, 0x10, 0x0e, 0x01, 0x1e, 0x00 },   // 0x73, s
    { 0x07, 0x08, 0x08, 0x1c, 0x08, 0x08, 0x09, 0x06, 0x00 },   // 0x74, t
    { 0x07, 0x00, 0x00, 0x11, 0x11, 0x11, 0x13, 0x0d, 0x00 },   // 0x75, u
    { 0x07, 0x00, 0x00, 0x11, 0x11, 0x11, 0x0a, 0x04, 0x00 },   // 0x76, v
    { 0x07, 0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0a, 0x00 },   // 0x77, w
    { 0x07, 0x00, 0x00, 0x11, 0x0a, 0x04, 0x0a, 0x11, 0x00 },   // 0x78, x
    { 0x07, 0x00, 0x00, 0x11, 0x11, 0x0f, 0x01, 0x11, 0x0e },   // 0x79, y
    { 0x07, 0x00, 0x00, 0x1f, 0x02, 0x04, 0x08, 0x1f, 0x00 },   // 0x7a, z
    { 0x07, 0x06, 0x08, 0x08, 0x10, 0x08, 0x08, 0x06, 0x00 },   // 0x7b, {
    { 0x07, 0x04, 0x04, 0x04, 0x00, 0x04, 0x04, 0x04, 0x00 },   // 0x7c, |
    { 0x07, 0x0c, 0x02, 0x02, 0x01, 0x02, 0x02, 0x0c, 0x00 },   // 0x7d, }
    { 0x07, 0x08, 0x15, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00 },   // 0x7e, ~
    { 0x07, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x00 }    // 0x7f, DEL
};


void helpArr_init(void)
{
  unsigned short i, j, k;
  j = 0;
  k = 0;
  for (i = 0; i < anzMAX * 8; i++) {
    helpArrPos[i] = (1 << j);   //bitmask
    helpArrMAX[i] = k;
    j++;
    if (j > 7) {
      j = 0;
      k++;
    }
  }
}

void char2Arr(unsigned short ch, int PosX, short PosY) { //字符写入 arr
  int i, j, k, l, m, o1, o2, o3, o4;  //in LEDarr
  PosX++;
  k = ch - 32;                        //字体中的ASCII位置
  if ((k >= 0) && (k < 96))           //在字体中找到字符?
  {
    o4 = font1[k][0];                 //字符宽度
    o3 = 1 << (o4 - 2);
    for (i = 0; i < o4; i++) {
      if (((PosX - i <= maxPosX) && (PosX - i >= 0))
          && ((PosY > -8) && (PosY < 8))) //矩阵内?
      {
        o1 = helpArrPos[PosX - i];
        o2 = helpArrMAX[PosX - i];
        for (j = 0; j < 8; j++) {
          if (((PosY >= 0) && (PosY <= j)) || ((PosY < 0) && (j < PosY + 8))) //垂直滚动
          {
            l = font1[k][j + 1];
            m = (l & (o3 >> i));  //e.g. o4=7  0zzzzz0, o4=4  0zz0
            if (m > 0)
              LEDarr[o2][j - PosY] = LEDarr[o2][j - PosY] | (o1);  //设置坐标
            else
              LEDarr[o2][j - PosY] = LEDarr[o2][j - PosY] & (~o1); //清除坐标
          }
        }
      }
    }
  }
}

void timer50ms() {
  static unsigned int cnt50ms = 0;
  static unsigned int cnt1s = 0;
  static unsigned int cnt1h = 0;
  f_tckr50ms = true;
  cnt50ms++;
  if (cnt50ms == 20) {
    f_tckr1s = true; // 1秒
    cnt1s++;
    cnt50ms = 0;
  }
  if (cnt1s == 3600) { // 1小时
    cnt1h++;
    cnt1s = 0;
  }
  if (cnt1h == 24) { // 1天
    f_tckr24h = true;
    cnt1h = 0;
  }
}

void setup() {
  pinMode(CS, OUTPUT);
  digitalWrite(CS, HIGH);
  Serial.begin(115200);
  //rtc.init(SDA, SCL);
  SPI.begin();
  helpArr_init();
  max7219_init();
  rtc_init(SDA, SCL);
  clear_Display();
  //显示启动
  char2Arr('g', maxPosX - 42, 0);
  char2Arr('n', maxPosX - 38, 0);
  char2Arr('i', maxPosX - 32, 0);
  char2Arr('t', maxPosX - 26, 0);
  char2Arr('r', maxPosX - 20, 0);
  char2Arr('a', maxPosX - 14, 0);
  char2Arr('t', maxPosX - 8, 0);
  char2Arr('S', maxPosX - 2, 0);
  refresh_display();
  
  tckr.attach(0.05, timer50ms);    // 每 50 毫秒
  initWifi();
  timeClient.begin();
  tm* tt = connectNTP();
  if (tt != NULL){
    rtc_set(tt);
  }else{
    Serial.println("no timepacket received");
  }
}

void loop() {
  unsigned int sec1 = 0, sec2 = 0, min1 = 0, min2 = 0, hour1 = 0, hour2 = 0;
  unsigned int sec11 = 0, sec12 = 0, sec21 = 0, sec22 = 0;
  unsigned int min11 = 0, min12 = 0, min21 = 0, min22 = 0;
  unsigned int hour11 = 0, hour12 = 0, hour21 = 0, hour22 = 0;
  signed int x = 0; //x1,x2;
  signed int y = 0, y1 = 0, y2 = 0;
  bool updown = false;
  unsigned int sc1 = 0, sc2 = 0, sc3 = 0, sc4 = 0, sc5 = 0, sc6 = 0;
  bool f_scrollend_y = false;
  unsigned int f_scroll_x = false;

  z_PosX = maxPosX;
  d_PosX = -8;
  //  x=0; x1=0; x2=0;

  refresh_display();
  if (updown == true) { //上下滚动
    y2 = 8;
    y1 = -8;
  }else{
    y2 = -9;
    y1 = 8;
  }
  while (true) {
    yield();
    if (f_tckr24h == true) { //每天同步RTC
      f_tckr24h = false;
      tm* tt = connectNTP();
      if (tt != NULL)
        rtc_set(tt);
      else
        Serial.println("no timepacket received");
    }
    if (f_tckr1s == true)        //标志1秒
    {
      rtc2tm();
      sec1 = TM.sec1;
      sec2 = TM.sec2;
      min1 = TM.min1;
      min2 = TM.min2;
      hour1 = TM.hour1;
      hour2 = TM.hour2;
      y = y2;                 //上下滚动
      sc1 = 1;
      sec1++;
      if (sec1 == 10) {
        sc2 = 1;
        sec2++;
        sec1 = 0;
      }
      if (sec2 == 6) {
        min1++;
        sec2 = 0;
        sc3 = 1;
      }
      if (min1 == 10) {
        min2++;
        min1 = 0;
        sc4 = 1;
      }
      if (min2 == 6) {
        hour1++;
        min2 = 0;
        sc5 = 1;
      }
      if (hour1 == 10) {
        hour2++;
        hour1 = 0;
        sc6 = 1;
      }
      if ((hour2 == 2) && (hour1 == 4)) {
        hour1 = 0;
        hour2 = 0;
        sc6 = 1;
      }

      sec11 = sec12;
      sec12 = sec1;
      sec21 = sec22;
      sec22 = sec2;
      min11 = min12;
      min12 = min1;
      min21 = min22;
      min22 = min2;
      hour11 = hour12;
      hour12 = hour1;
      hour21 = hour22;
      hour22 = hour2;
      f_tckr1s = false;
      if (TM.sec12 == 45)
        f_scroll_x = true;
    } // end 1s
    if (f_tckr50ms == true) {
      f_tckr50ms = false;
      if (f_scroll_x == true) {
        z_PosX++;
        d_PosX++;
        if (d_PosX == 101)
          z_PosX = 0;
        if (z_PosX == maxPosX) {
          f_scroll_x = false;
          d_PosX = -8;
        }
      }
      //秒1
      if (sc1 == 1) {
        if (updown == 1)
          y--;
        else
          y++;
        char2Arr(48 + sec12, z_PosX - 42, y);
        char2Arr(48 + sec11, z_PosX - 42, y + y1);
        if (y == 0) {
          sc1 = 0;
          f_scrollend_y = true;
        }
      }
      else
        char2Arr(48 + sec1, z_PosX - 42, 0);
      //秒2
      if (sc2 == 1) {
        char2Arr(48 + sec22, z_PosX - 36, y);
        char2Arr(48 + sec21, z_PosX - 36, y + y1);
        if (y == 0)
          sc2 = 0;
      }
      else
        char2Arr(48 + sec2, z_PosX - 36, 0);

      char2Arr(':', z_PosX - 32, 0);
      //分1
      if (sc3 == 1) {
        char2Arr(48 + min12, z_PosX - 25, y);
        char2Arr(48 + min11, z_PosX - 25, y + y1);
        if (y == 0)
          sc3 = 0;
      }
      else
        char2Arr(48 + min1, z_PosX - 25, 0);
      //分2
      if (sc4 == 1) {
        char2Arr(48 + min22, z_PosX - 19, y);
        char2Arr(48 + min21, z_PosX - 19, y + y1);
        if (y == 0)
          sc4 = 0;
      }
      else
        char2Arr(48 + min2, z_PosX - 19, 0);

      char2Arr(':', z_PosX - 15 + x, 0);
      //时1
      if (sc5 == 1) {
        char2Arr(48 + hour12, z_PosX - 8, y);
        char2Arr(48 + hour11, z_PosX - 8, y + y1);
        if (y == 0)
          sc5 = 0;
      }
      else
        char2Arr(48 + hour1, z_PosX - 8, 0);
      //时2
      if (sc6 == 1) {
        char2Arr(48 + hour22, z_PosX - 2, y);
        char2Arr(48 + hour21, z_PosX - 2, y + y1);
        if (y == 0)
          sc6 = 0;
      }
      else
        char2Arr(48 + hour2, z_PosX - 2, 0);

        

      char2Arr(WK_arr[TM.WK][0], d_PosX - 5, 0);        //周
      char2Arr(WK_arr[TM.WK][1], d_PosX - 11, 0);
      char2Arr(WK_arr[TM.WK][2], d_PosX - 17, 0);
      char2Arr(WK_arr[TM.WK][3], d_PosX - 23, 0);
      char2Arr(48 + TM.day2, d_PosX - 27, 0);           //日
      char2Arr(48 + TM.day1, d_PosX - 33, 0);
      char2Arr(M_arr[TM.mon12 - 1][0], d_PosX - 39, 0); //月
      char2Arr(M_arr[TM.mon12 - 1][1], d_PosX - 43, 0);
      char2Arr(M_arr[TM.mon12 - 1][2], d_PosX - 49, 0);
      char2Arr(M_arr[TM.mon12 - 1][3], d_PosX - 55, 0);
      char2Arr(M_arr[TM.mon12 - 1][4], d_PosX - 61, 0);
      char2Arr('2', d_PosX - 68, 0);                     //年
      char2Arr('0', d_PosX - 74, 0);
      char2Arr(48 + TM.year2, d_PosX - 80, 0);
      char2Arr(48 + TM.year1, d_PosX - 88, 0);

      refresh_display(); //alle 50ms
      if (f_scrollend_y == true) {
        f_scrollend_y = false;
      }
    } //end 50ms
    if (y == 0) {
      
    }
  }

}
